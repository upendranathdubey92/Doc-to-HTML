<!DOCTYPE html>
<html>
<head>
    <title>QA Edge Cases & Error Handling Tests</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .test-suite { background: white; margin: 20px 0; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .test-case { margin: 15px 0; padding: 15px; border-left: 4px solid #ddd; background: #fafafa; }
        .test-pass { border-left-color: #4caf50; background: #f1f8e9; }
        .test-fail { border-left-color: #f44336; background: #ffebee; }
        .test-warning { border-left-color: #ff9800; background: #fff3e0; }
        .test-title { font-weight: bold; margin-bottom: 10px; }
        .test-result { font-size: 14px; margin: 5px 0; }
        .test-input { background: #f8f8f8; padding: 10px; margin: 10px 0; font-family: monospace; font-size: 12px; border: 1px solid #ddd; }
        .stats { background: #e3f2fd; padding: 15px; margin: 20px 0; border-radius: 4px; }
        .run-all { background: #2196f3; color: white; padding: 12px 24px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; margin: 20px 0; }
        .run-all:hover { background: #1976d2; }
        h1 { color: #333; text-align: center; }
        h2 { color: #555; border-bottom: 2px solid #ddd; padding-bottom: 10px; }
        .severity { padding: 2px 8px; border-radius: 3px; font-size: 12px; font-weight: bold; }
        .high { background: #ffcdd2; color: #c62828; }
        .medium { background: #ffe0b2; color: #ef6c00; }
        .low { background: #c8e6c9; color: #2e7d32; }
    </style>
</head>
<body>
    <h1>🧪 QA Edge Cases & Error Handling Tests</h1>
    <div class="stats" id="testStats">
        <strong>Test Status:</strong> Ready to test edge cases and error handling
    </div>
    
    <button class="run-all" onclick="runAllEdgeCaseTests()">🧪 Run Edge Case Tests</button>
    
    <div id="testResults"></div>

    <script>
        // Copy detection logic from main file
        const supportedSections = ['HERO', 'FAQ', 'CTA_SIMPLE', 'CTA_ENHANCED', 'CTA_TWO', 'PROCESS', 'TECHNOLOGY', 'INDUSTRIES', 'SERVICES_GRID', 'SERVICES_ACCORDION', 'PORTFOLIO', 'TESTIMONIAL', 'BENEFITS', 'BENEFITS_TWO', 'CONTENT_FORM'];
        
        function detectSections(content) {
            const sectionPattern = /\[([A-Z_\s]+)\]/g;
            const matches = [...content.matchAll(sectionPattern)];
            const detected = matches.map(match => match[1].trim());
            
            return [...new Set(detected)]
                .filter(section => !section.endsWith(' END'))
                .filter(section => 
                    supportedSections.some(supported => 
                        section.includes(supported) || supported.includes(section)
                    )
                );
        }

        // Edge case test scenarios
        const edgeCaseTests = [
            {
                name: "Empty Document Handling",
                severity: "high",
                category: "Input Validation",
                input: "",
                expectedBehavior: "Should return empty array without errors",
                test: () => {
                    const result = detectSections("");
                    return {
                        detected: result,
                        isEmpty: result.length === 0,
                        noErrors: true,
                        passed: result.length === 0
                    };
                }
            },
            {
                name: "Only Whitespace Document",
                severity: "high", 
                category: "Input Validation",
                input: "   \n\n\t\t   \n   ",
                expectedBehavior: "Should handle whitespace-only content gracefully",
                test: () => {
                    const result = detectSections("   \n\n\t\t   \n   ");
                    return {
                        detected: result,
                        isEmpty: result.length === 0,
                        passed: result.length === 0
                    };
                }
            },
            {
                name: "Malformed Section Markers",
                severity: "medium",
                category: "Parsing Robustness",
                input: "[HERO\nMissing closing bracket\n[HERO END]\n[FAQ]\nValid section\n[FAQ END]",
                expectedBehavior: "Should ignore malformed markers, detect valid ones",
                test: () => {
                    const result = detectSections("[HERO\nMissing closing bracket\n[HERO END]\n[FAQ]\nValid section\n[FAQ END]");
                    return {
                        detected: result,
                        ignoredMalformed: !result.includes("HERO"),
                        detectedValid: result.includes("FAQ"),
                        passed: !result.includes("HERO") && result.includes("FAQ")
                    };
                }
            },
            {
                name: "Nested Brackets in Content",
                severity: "medium",
                category: "Content Parsing",
                input: "[HERO]\nContent with [nested] brackets and [more nested] content\n[HERO END]",
                expectedBehavior: "Should detect section markers, ignore content brackets",
                test: () => {
                    const result = detectSections("[HERO]\nContent with [nested] brackets and [more nested] content\n[HERO END]");
                    return {
                        detected: result,
                        detectedHero: result.includes("HERO"),
                        ignoredNested: !result.includes("nested") && !result.includes("more nested"),
                        passed: result.includes("HERO") && result.length === 1
                    };
                }
            },
            {
                name: "Mixed Case Section Names",
                severity: "medium",
                category: "Case Sensitivity",
                input: "[hero]\nLowercase section\n[hero end]\n[Hero]\nMixed case\n[Hero End]\n[HERO]\nCorrect case\n[HERO END]",
                expectedBehavior: "Should only detect properly cased sections",
                test: () => {
                    const result = detectSections("[hero]\nLowercase section\n[hero end]\n[Hero]\nMixed case\n[Hero End]\n[HERO]\nCorrect case\n[HERO END]");
                    return {
                        detected: result,
                        correctCase: result.includes("HERO"),
                        ignoredLowercase: !result.includes("hero"),
                        ignoredMixedCase: !result.includes("Hero"),
                        passed: result.includes("HERO") && !result.includes("hero") && !result.includes("Hero")
                    };
                }
            },
            {
                name: "Extremely Long Content",
                severity: "low",
                category: "Performance",
                input: generateLargeContent(),
                expectedBehavior: "Should handle large content efficiently",
                test: () => {
                    const largeContent = generateLargeContent();
                    const startTime = performance.now();
                    const result = detectSections(largeContent);
                    const endTime = performance.now();
                    const processingTime = endTime - startTime;
                    
                    return {
                        detected: result,
                        processingTime: processingTime.toFixed(2) + 'ms',
                        contentSize: largeContent.length,
                        performanceGood: processingTime < 100,
                        detectedHero: result.includes("HERO"),
                        passed: processingTime < 100 && result.includes("HERO")
                    };
                }
            },
            {
                name: "Special Characters in Section Names",
                severity: "medium",
                category: "Character Handling",
                input: "[HERO@]\nSection with special char\n[HERO@ END]\n[HERO_123]\nSection with underscore and numbers\n[HERO_123 END]",
                expectedBehavior: "Should handle underscores, ignore other special chars",
                test: () => {
                    const result = detectSections("[HERO@]\nSection with special char\n[HERO@ END]\n[HERO_123]\nSection with underscore and numbers\n[HERO_123 END]");
                    return {
                        detected: result,
                        ignoredSpecialChar: !result.includes("HERO@"),
                        allowedUnderscore: result.includes("HERO_123"),
                        passed: !result.includes("HERO@") && result.includes("HERO_123")
                    };
                }
            },
            {
                name: "Unicode Characters in Content",
                severity: "low",
                category: "Character Encoding",
                input: "[HERO]\nTitle with émojis 🚀 and ñiño characters\nDescription with various unicode: © ® ™ € £ ¥\n[HERO END]",
                expectedBehavior: "Should handle unicode content without issues",
                test: () => {
                    const result = detectSections("[HERO]\nTitle with émojis 🚀 and ñiño characters\nDescription with various unicode: © ® ™ € £ ¥\n[HERO END]");
                    return {
                        detected: result,
                        detectedHero: result.includes("HERO"),
                        handledUnicode: true,
                        passed: result.includes("HERO")
                    };
                }
            },
            {
                name: "No END Markers",
                severity: "high",
                category: "Parsing Robustness", 
                input: "[HERO]\nContent without end marker\n[FAQ]\nAnother section without end",
                expectedBehavior: "Should detect sections even without END markers",
                test: () => {
                    const result = detectSections("[HERO]\nContent without end marker\n[FAQ]\nAnother section without end");
                    return {
                        detected: result,
                        detectedHero: result.includes("HERO"),
                        detectedFaq: result.includes("FAQ"),
                        passed: result.includes("HERO") && result.includes("FAQ")
                    };
                }
            },
            {
                name: "Duplicate Section Names",
                severity: "medium",
                category: "Duplicate Handling",
                input: "[HERO]\nFirst hero section\n[HERO END]\n[HERO]\nSecond hero section\n[HERO END]\n[HERO]\nThird hero section\n[HERO END]",
                expectedBehavior: "Should deduplicate section names in detection",
                test: () => {
                    const result = detectSections("[HERO]\nFirst hero section\n[HERO END]\n[HERO]\nSecond hero section\n[HERO END]\n[HERO]\nThird hero section\n[HERO END]");
                    return {
                        detected: result,
                        uniqueCount: result.length,
                        detectedHero: result.includes("HERO"),
                        properlyDeduplicated: result.filter(s => s === "HERO").length === 1,
                        passed: result.includes("HERO") && result.filter(s => s === "HERO").length === 1
                    };
                }
            },
            {
                name: "HTML/XML Tags in Content",
                severity: "medium",
                category: "Content Security",
                input: "[HERO]\n<script>alert('xss')</script>\n<div>Some HTML content</div>\n<img src='x' onerror='alert(1)'>\n[HERO END]",
                expectedBehavior: "Should detect section, not be affected by HTML content",
                test: () => {
                    const result = detectSections("[HERO]\n<script>alert('xss')</script>\n<div>Some HTML content</div>\n<img src='x' onerror='alert(1)'>\n[HERO END]");
                    return {
                        detected: result,
                        detectedHero: result.includes("HERO"),
                        ignoredHtmlTags: !result.includes("script") && !result.includes("div"),
                        passed: result.includes("HERO") && result.length === 1
                    };
                }
            },
            {
                name: "Section Priority Order",
                severity: "high",
                category: "Section Matching",
                input: "[CTA_TWO]\nShould be detected as CTA_TWO not CTA\n[CTA_TWO END]",
                expectedBehavior: "Should prioritize CTA_TWO over CTA when both could match",
                test: () => {
                    const result = detectSections("[CTA_TWO]\nShould be detected as CTA_TWO not CTA\n[CTA_TWO END]");
                    return {
                        detected: result,
                        detectedCtaTwo: result.includes("CTA_TWO"),
                        didNotDetectCta: !result.includes("CTA_SIMPLE"),
                        correctPriority: result.includes("CTA_TWO") && !result.includes("CTA_SIMPLE"),
                        passed: result.includes("CTA_TWO") && !result.includes("CTA_SIMPLE")
                    };
                }
            },
            {
                name: "Null/Undefined Input Handling",
                severity: "high",
                category: "Input Validation",
                input: null,
                expectedBehavior: "Should handle null input gracefully without crashing",
                test: () => {
                    try {
                        const result1 = detectSections(null);
                        const result2 = detectSections(undefined);
                        return {
                            nullHandled: true,
                            nullResult: result1,
                            undefinedResult: result2,
                            noErrors: true,
                            passed: true
                        };
                    } catch (error) {
                        return {
                            nullHandled: false,
                            error: error.message,
                            noErrors: false,
                            passed: false
                        };
                    }
                }
            }
        ];

        function generateLargeContent() {
            let content = '[HERO]\n';
            for (let i = 0; i < 5000; i++) {
                content += `Line ${i}: This is a test line with some content to make it longer and test performance with large documents.\n`;
            }
            content += '[HERO END]\n';
            return content;
        }

        function runEdgeCaseTest(testCase) {
            try {
                const result = testCase.test();
                return {
                    name: testCase.name,
                    severity: testCase.severity,
                    category: testCase.category,
                    expectedBehavior: testCase.expectedBehavior,
                    input: typeof testCase.input === 'string' && testCase.input.length > 200 ? 
                           testCase.input.substring(0, 200) + '...' : testCase.input,
                    status: result.passed ? 'pass' : 'fail',
                    result: result,
                    error: null
                };
            } catch (error) {
                return {
                    name: testCase.name,
                    severity: testCase.severity,
                    category: testCase.category,
                    expectedBehavior: testCase.expectedBehavior,
                    input: testCase.input,
                    status: 'fail',
                    result: null,
                    error: error.message
                };
            }
        }

        function runAllEdgeCaseTests() {
            const startTime = performance.now();
            const results = edgeCaseTests.map(runEdgeCaseTest);
            const endTime = performance.now();
            
            const passed = results.filter(r => r.status === 'pass').length;
            const failed = results.filter(r => r.status === 'fail').length;
            const total = results.length;
            
            const highSeverityFailed = results.filter(r => r.status === 'fail' && r.severity === 'high').length;
            const mediumSeverityFailed = results.filter(r => r.status === 'fail' && r.severity === 'medium').length;
            
            // Update stats
            document.getElementById('testStats').innerHTML = `
                <strong>Edge Case Tests:</strong> ${passed}/${total} passed (${failed} failed) | 
                <strong>High Severity Failed:</strong> ${highSeverityFailed} |
                <strong>Medium Severity Failed:</strong> ${mediumSeverityFailed} |
                <strong>Execution Time:</strong> ${(endTime - startTime).toFixed(2)}ms |
                <strong>Success Rate:</strong> ${((passed/total)*100).toFixed(1)}%
            `;
            
            // Display results
            const resultsHtml = generateEdgeCaseResultsHtml(results);
            document.getElementById('testResults').innerHTML = resultsHtml;
        }

        function generateEdgeCaseResultsHtml(results) {
            const categories = [...new Set(results.map(r => r.category))];
            
            let html = '';
            for (let category of categories) {
                const categoryResults = results.filter(r => r.category === category);
                const passed = categoryResults.filter(r => r.status === 'pass').length;
                
                html += `<div class="test-suite">
                    <h2>🧪 ${category} Tests (${passed}/${categoryResults.length} passed)</h2>`;
                
                for (let result of categoryResults) {
                    const cssClass = result.status === 'pass' ? 'test-pass' : 'test-fail';
                    const icon = result.status === 'pass' ? '✅' : '❌';
                    const severityClass = result.severity;
                    
                    html += `<div class="test-case ${cssClass}">
                        <div class="test-title">
                            ${icon} ${result.name} 
                            <span class="severity ${severityClass}">${result.severity.toUpperCase()}</span>
                        </div>
                        <div class="test-result">
                            <strong>Expected Behavior:</strong> ${result.expectedBehavior}
                        </div>`;
                    
                    if (result.input !== null && result.input !== undefined) {
                        html += `<div class="test-input">
                            <strong>Test Input:</strong><br>${typeof result.input === 'string' ? escapeHtml(result.input) : JSON.stringify(result.input)}
                        </div>`;
                    }
                    
                    if (result.status === 'pass') {
                        html += `<div class="test-result">
                            <strong>Test Results:</strong><br><pre>${JSON.stringify(result.result, null, 2)}</pre>
                        </div>`;
                    } else {
                        html += `<div class="test-result">
                            <strong>Error:</strong> ${result.error || 'Test failed - see result details'}
                            ${result.result ? '<br><strong>Partial Results:</strong><br><pre>' + JSON.stringify(result.result, null, 2) + '</pre>' : ''}
                        </div>`;
                    }
                    
                    html += `</div>`;
                }
                
                html += `</div>`;
            }
            
            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Auto-run tests on page load
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(runAllEdgeCaseTests, 1000);
        });
    </script>
</body>
</html>