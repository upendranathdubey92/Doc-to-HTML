<!DOCTYPE html>
<html>
<head>
    <title>Full IDE Logic Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        textarea { width: 100%; height: 300px; }
        .results { margin-top: 20px; padding: 10px; border: 1px solid #ccc; }
        .step { margin: 10px 0; padding: 10px; background: #f5f5f5; }
        .error { background: #ffebee; color: #c62828; }
        .success { background: #e8f5e8; color: #2e7d32; }
    </style>
</head>
<body>
    <h1>Full IDE Logic Test</h1>
    
    <textarea id="testContent">[BENEFITS2]
Key Benefits of Web Development Consulting Services
Partnering with a web development consulting company offers more than just technical guidance; it delivers strategic insights, tailored solutions, and expert recommendations to elevate your digital presence.
Eliminate Performance Issues
Transform slow-loading websites that drive customers away into fast, responsive platforms. Professional consulting identifies the exact causes of performance issues and implements solutions that significantly reduce bounce rates.
Boost Conversion Rates
Convert more visitors into paying customers through strategic user experience optimization. Web development consultants address checkout friction, navigation problems, and trust signals that directly impact your revenue generation.
[BENEFITS2 END]</textarea>
    
    <br><br>
    <button onclick="testFullLogic()">Test Full IDE Logic</button>
    
    <div id="results" class="results"></div>

    <script>
        // Copy exact logic from web IDE
        const supportedSections = ['HERO', 'FAQ', 'CTA_SIMPLE', 'CTA_ENHANCED', 'PROCESS', 'TECHNOLOGY', 'INDUSTRIES', 'SERVICES_GRID', 'SERVICES_ACCORDION', 'PORTFOLIO', 'TESTIMONIAL', 'BENEFITS', 'BENEFITS2', 'CONTENT_FORM'];
        
        function detectSections(content) {
            const sectionPattern = /\[([A-Z_\s]+)\]/g;
            const matches = [...content.matchAll(sectionPattern)];
            const detected = matches.map(match => match[1].trim());
            
            return [...new Set(detected)].filter(section => 
                supportedSections.some(supported => 
                    section.includes(supported) || supported.includes(section)
                )
            );
        }
        
        async function parseRealDocument(content) {
            const sections = {};
            
            // Find section markers - handle both [SECTION] and [SECTION END] format
            const lines = content.split('\n');
            let currentSection = null;
            let currentContent = [];
            
            for (let line of lines) {
                const trimmedLine = line.trim();
                
                // Check for section start markers
                const sectionStartMatch = trimmedLine.match(/^\[([A-Z_\s]+)\]$/);
                if (sectionStartMatch && !sectionStartMatch[1].endsWith(' END')) {
                    // Save previous section if exists
                    if (currentSection && currentContent.length > 0) {
                        const contentText = currentContent.join('\n').trim();
                        sections[currentSection] = { raw_content: contentText }; // Simplified parsing
                    }
                    
                    // Start new section
                    currentSection = sectionStartMatch[1].trim();
                    currentContent = [];
                }
                // Check for section end markers
                else if (trimmedLine.match(/^\[([A-Z_\s]+) END\]$/)) {
                    // End current section
                    if (currentSection && currentContent.length > 0) {
                        const contentText = currentContent.join('\n').trim();
                        sections[currentSection] = { raw_content: contentText }; // Simplified parsing
                    }
                    
                    currentSection = null;
                    currentContent = [];
                }
                // Add content to current section
                else if (currentSection) {
                    currentContent.push(line);
                }
            }
            
            // Handle sections without END markers
            if (currentSection && currentContent.length > 0) {
                const contentText = currentContent.join('\n').trim();
                sections[currentSection] = { raw_content: contentText }; // Simplified parsing
            }
            
            return sections;
        }
        
        async function testFullLogic() {
            const content = document.getElementById('testContent').value;
            const resultsDiv = document.getElementById('results');
            
            let html = '';
            
            try {
                // Step 1: Detect sections
                const detectedSections = detectSections(content);
                html += '<div class="step">';
                html += '<h3>Step 1: Detect Sections</h3>';
                html += '<p><strong>Detected sections:</strong> ' + JSON.stringify(detectedSections) + '</p>';
                html += '<p><strong>Count:</strong> ' + detectedSections.length + '</p>';
                html += '</div>';
                
                if (detectedSections.length === 0) {
                    html += '<div class="step error">';
                    html += '<h3>❌ Error: No valid sections found</h3>';
                    html += '</div>';
                    resultsDiv.innerHTML = html;
                    return;
                }
                
                // Step 2: Parse document
                const sections = await parseRealDocument(content);
                html += '<div class="step">';
                html += '<h3>Step 2: Parse Document</h3>';
                html += '<p><strong>Parsed sections:</strong> ' + JSON.stringify(Object.keys(sections)) + '</p>';
                
                Object.entries(sections).forEach(([sectionType, sectionContent]) => {
                    html += '<p><strong>' + sectionType + ':</strong> ' + sectionContent.raw_content.substring(0, 100) + '...</p>';
                });
                html += '</div>';
                
                // Step 3: Check supported sections filter
                html += '<div class="step">';
                html += '<h3>Step 3: Filter Supported Sections</h3>';
                
                const filteredSections = {};
                Object.entries(sections).forEach(([sectionType, sectionContent]) => {
                    const isSupported = supportedSections.some(s => sectionType.includes(s));
                    html += '<p><strong>' + sectionType + ':</strong> ' + (isSupported ? '✅ Supported' : '❌ Not supported') + '</p>';
                    if (isSupported) {
                        filteredSections[sectionType] = sectionContent;
                    }
                });
                html += '<p><strong>Final sections to generate:</strong> ' + JSON.stringify(Object.keys(filteredSections)) + '</p>';
                html += '</div>';
                
                html += '<div class="step success">';
                html += '<h3>✅ Success: ' + Object.keys(filteredSections).length + ' sections ready for generation</h3>';
                html += '</div>';
                
            } catch (error) {
                html += '<div class="step error">';
                html += '<h3>❌ Error: ' + error.message + '</h3>';
                html += '</div>';
            }
            
            resultsDiv.innerHTML = html;
        }
    </script>
</body>
</html>